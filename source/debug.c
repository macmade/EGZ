/*******************************************************************************
 * Copyright (c) 2010, Jean-David Gadina - www.xs-labs.com
 * Distributed under the Boost Software License, Version 1.0.
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

/* $Id$ */

/*!
 * @file        print.c
 * @copyright   (c) 2011 - Jean-David Gadina - www.xs-labs.com
 * @abstract    Program's print functions
 */

/* Local includes */
#include "egz.h"

/*!
 * 
 */
void egz_print_table( egz_table * table )
{
    unsigned int i;
    
    /* Prints the table header */
    printf
    (
        "\n"
        "    -------------------------------------------------------------------------------------------\n"
        "    | Number of symbols:                                       %30u |\n"
        "    | Number of bytes:                                         %30lu |\n"
        "    | Information content:                                     %30.10f |\n"
        "    | Total entropy:                                           %30.10f |\n"
        "    | Expected compression ratio:                                                   %7.2f %% |\n"
        "    |-----------------------------------------------------------------------------------------|\n"
        "    | Character:  | Occurences:     | Frequency:   | Information content:  | Entropy:         |\n"
        "    |-------------|-----------------|--------------|-----------------------|------------------|\n",
        table->count,
        table->total,
        table->information,
        table->entropy,
        ( 1 - ( table->information / ( table->total * 8 ) ) ) * 100
    );
    
    /* Process each ASCII character */
    for( i = 0; i < 256; i++ )
    {
        /* Printable character (other than a space) with occurences */
        if( isprint( i ) && table->symbols[ i ].character != 0x20 && table->symbols[ i ].occurences > 0 )
        {
            /* Prints the character informations */
            printf
            (
                "    | 0x%02X:   %c   | %015lu | %.10f | %021.15f | %016.10f |",
                i,
                i,
                table->symbols[ i ].occurences,
                table->symbols[ i ].frequency,
                table->symbols[ i ].information,
                table->symbols[ i ].entropy
            );
        }
        
        /* Non-printable character (or space) with occurences */
        else if( table->symbols[ i ].occurences > 0 )
        {
            /* Prints the character informations */
            printf
            (
                "    | 0x%02X: ..... | %015lu | %.10f | %021.15f | %016.10f |",
                i,
                table->symbols[ i ].occurences,
                table->symbols[ i ].frequency,
                table->symbols[ i ].information,
                table->symbols[ i ].entropy
            );
        }
        
        /* Printable character (other than a space) with no occurency */
        else if( isprint( i ) && table->symbols[ i ].character != 0x20 )
        {
            /* Prints the character informations */
            printf
            (
                "    | 0x%02X:   %c   | %015lu | %.10f | ..................... | ................ |",
                i,
                i,
                table->symbols[ i ].occurences,
                table->symbols[ i ].frequency
            );
        }
        
        /* Non-printable character (or space) with no occurency */
        else
        {
            /* Prints the character informations */
            printf
            (
                "    | 0x%02X: ..... | %015lu | %.10f | ..................... | ................ |",
                i,
                table->symbols[ i ].occurences,
                table->symbols[ i ].frequency
            );
        }
        
        printf( "\n" );
    }
    
    printf( "    -------------------------------------------------------------------------------------------\n\n" );
}

/*!
 * 
 */
void egz_print_symbols( egz_symbol ** symbols, unsigned int count )
{
    unsigned int i;
    unsigned int j;
    egz_symbol * symbol;
    
    i = count;
    j = 0;
    
    /* Prints the table's header */
    printf(
           "\n"
           "    ---------------------------------------------------------------------------------------------\n"
           "    | Character:  Percent: | Character:  Percent: | Character:  Percent: | Character:  Percent: |\n"
           "    |----------------------|----------------------|----------------------|----------------------|\n"
           "    "
    );
    
    /* Process each symbol */
    while( i != 0 )
    {
        /* Current symbol */
        symbol = symbols[ --i ];
        
        /* Checks if it's representing a printable character (other than a space) */
        if( isprint( symbol->character ) && symbol->character != 0x20 )
        {
            /* Prints the symbol informations */
            printf( "| 0x%02X:   %c   %.4f %%", symbol->character, symbol->character, symbol->frequency );
        }
        else
        {
            /* Prints the symbol informations */
            printf( "| 0x%02X: ..... %.4f %%", symbol->character, symbol->frequency );
        }
        
        /* No more symbol */
        if( i == 0 )
        {
            /* Ends the remaining columns */
            while( j != 3 )
            {
                printf( " |                     " );
                j++;
            }
        }
        
        /* New line character or space, depending if we have reached the end of the table (4 symbols) */
        if( j == 3 )
        {
            printf( " |\n    " );
            j = 0;
        }
        else
        {
            printf( " " );
            j++;
        }
    }
    
    /* Prints the end of the table */
    printf( "---------------------------------------------------------------------------------------------\n\n" );
}

/*!
 * 
 */
void egz_print_node( egz_symbol * node )
{
    char s1[ 12 ];
    char s2[ 12 ];
    
    memset( s1, 0, 12 );
    memset( s2, 0, 12 );
    
    /* Checks if we have a left child */
    if( node->left == NULL )
    {
        /* No */
        sprintf( s1, "   [ ? ]   " );
    }
    
    /* Checks if the left child is a leaf node */
    else if( node->left->id != 0 )
    {
        /* No - only prints the ID of the left child */
        sprintf( s1, "   [%03u]   ", node->left->id );
    }
    
    /* Checks if it's representing a printable character (other than a space) */
    else if( isprint( node->left->character ) && node->left->character != 0x20 )
    {
        /* Yes - Prints the character */
        sprintf( s1, "0x%02X:   %c  ", node->left->character, node->left->character );
    }
    else
    {
        /* No - Prints dots instead */
        sprintf( s1, "0x%02X: .....", node->left->character );

    }
    
    /* Checks if we have a left child */
    if( node->right == NULL )
    {
        /* No */
        sprintf( s2, "   [ ? ]   " );
    }
    
    /* Checks if the right child is a leaf node */
    else if( node->right->id != 0 )
    {
        /* No - only prints the ID of the left child */
        sprintf( s2, "   [%03u]   ", node->right->id );
    }
    
    /* Checks if it's representing a printable character (other than a space) */
    else if( isprint( node->right->character ) && node->right->character != 0x20 )
    {
        /* Yes - Prints the character */
        sprintf( s2, "0x%02X:   %c  ", node->right->character, node->right->character );
    }
    else
    {
        /* No - Prints dots instead */
        sprintf( s2, "0x%02X: .....", node->right->character );

    }
    
    /* Prints the final representation of the node */
    printf
    (
        "\n"
        "                           ---------------------------\n"
        "                           | [%03u] | %015lu |\n"
        "                           ---------------------------\n"
        "                                        |\n"
        "                                       [+]\n"
        "                                     ___|___\n"
        "                                    |       |\n"
        "    ---------------------------------       ---------------------------------\n"
        "    | %015lu | %s |       | %s | %015lu |\n"
        "    ---------------------------------       ---------------------------------\n"
        "\n",
        node->id,
        node->occurences,
        ( node->left != NULL ) ? node->left->occurences : 0,
        s1,
        s2,
        ( node->right != NULL ) ? node->right->occurences : 0
    );
}

/*!
 * 
 */
void egz_print_codes( egz_symbol ** symbols, unsigned int count )
{
    unsigned int i;
    unsigned int j;
    egz_symbol * symbol;
    
    i = count;
    j = 0;
    
    /* Prints the table's header */
    printf
    (
        "\n"
        "    -------------------------------------------------------------------------------------------------------------------\n"
        "    | Character:  | Occurences:     | Bits: | Binary code (64 bits max):                                              |\n"
        "    |-------------|-----------------|-------|-------------------------------------------------------------------------|\n"
    );
    
    /* Process each symbol */
    while( i != 0 )
    {
        /* Current symbol */
        symbol = symbols[ --i ];
        
        /* Checks if it's representing a printable character (other than a space) */
        if( isprint( symbol->character ) && symbol->character != 0x20 )
        {
            /* Prints the symbol informations */
            printf
            (
                "    | 0x%02X:   %c   | %015lu | %5u | ",
                symbol->character,
                symbol->character,
                symbol->occurences,
                symbol->bits
            );
        }
        else
        {
            /* Prints the symbol informations */
            printf
            (
                "    | 0x%02X: ..... | %015lu | %5u | ",
                symbol->character,
                symbol->occurences,
                symbol->bits
            );
        }
        
        /* Prints the symbol binary code */
        egz_print_binary_code( symbol );
        printf( " |\n" );
    }
    
    /* Prints the end of the table */
    printf( "    -------------------------------------------------------------------------------------------------------------------\n\n" );
}

void egz_print_binary_code( egz_symbol * node )
{
    unsigned int  i;
    unsigned int  j;
    unsigned char octet[ 74 ];
    
    /* We only have room for 64 bits on the debug output */
    if( node->bits > 64 )
    {
        printf( "xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx" );
        return;
    }
    
    /* Loop to display the state of 64 bits */
    for( i = 0; i < 64; i++ )
    {
        /* Offset for the char to set (as we are adding a space bewteen the bytes) */
        j = i;
        j = ( i < 8 )  ? j : j + 1;
        j = ( i < 16 ) ? j : j + 1;
        j = ( i < 24 ) ? j : j + 1;
        j = ( i < 32 ) ? j : j + 1;
        j = ( i < 40 ) ? j : j + 1;
        j = ( i < 48 ) ? j : j + 1;
        j = ( i < 56 ) ? j : j + 1;
        
        /* Separates bytes by a space */
        if( i == 8 || i == 17 || i == 26 || i == 35 || i == 44 || i == 53 || i == 62 )
        {
            octet[ i ] = 0x20;
        }
        
        /* Display a dot if no bit is set */
        if( i < 64 - node->bits )
        {
            octet[ j ] = '.';
        }
        else
        {
            /* Sets the 0 or 1 character for the current bit */
            octet[ j ] = ( ( node->code >> ( 63 - i ) ) & 0x1 ) ? '1' : '0';
        }
    }
    
    /* String termination */
    octet[ 73 ] = 0;
    
    /* Prints the binary code */
    printf( "%s", octet );
}

/*!
 * 
 */
void egz_print_statistics( egz_symbol ** symbols, unsigned int count )
{
    int           precision;
    unsigned int  i;
    unsigned long bits_original;
    unsigned long bits_compressed;
    unsigned long bytes_original;
    unsigned long bytes_compressed;
    double        size_original;
    double        size_compressed;
    char        * unit;
    egz_symbol  * symbol;
    
    bits_original   = 0;
    bits_compressed = 0;
    
    /* Process each symbol */
    for( i = 0; i < count; i++ )
    {
        /* Current symbol */
        symbol = symbols[ i ];
        
        /* Adds the number of bits used to represent the symbol in the original file */
        bits_original   += 8 * symbol->occurences;
        
        /* Adds the number of bits used to represent the symbol in the compressed file */
        bits_compressed += symbol->bits * symbol->occurences;
    }
    
    bytes_original   = bits_original   / 8;
    bytes_compressed = bits_compressed / 8;
    size_original    = 0;
    size_compressed  = 0;
    
    /* Checks the size range */
    if( bytes_original < 1000 )
    {
        /* Bytes */
        unit            = "B ";
        precision       = 0;
        size_original   = bytes_original;
        size_compressed = bytes_compressed;
    }
    else if( bytes_original < 1000000 )
    {
        /* Kilo-Bytes */
        unit            = "KB";
        precision       = 2;
        size_original   = ( double )bytes_original   / ( double )1000;
        size_compressed = ( double )bytes_compressed / ( double )1000;
    }
    else if( bytes_original < 1000000000 )
    {
        /* Mega-Bytes */
        unit            = "MB";
        precision       = 2;
        size_original   = ( ( double )bytes_original   / ( double )1000 ) / ( double )1000;
        size_compressed = ( ( double )bytes_compressed / ( double )1000 ) / ( double )1000;
    }
    else
    {
        /* Giga-Bytes */
        unit            = "GB";
        precision       = 2;
        size_original   = ( ( ( double )bytes_original   / ( double )1000 ) / ( double )1000 ) / ( double )1000;
        size_compressed = ( ( ( double )bytes_compressed / ( double )1000 ) / ( double )1000 ) / ( double )1000;
    }
    
    /* Prints the compression statistics */
    printf
    (
        "\n"
        "    -------------------------------------\n"
        "    | - Original size:     | %7.*f %s |\n"
        "    | - Compressed size:   | %7.*f %s |\n"
        "    |----------------------|------------|\n"
        "    | - Compression ratio: |  %7.2f %% |\n"
        "    -------------------------------------\n"
        "\n",
        precision,
        size_original,
        unit,
        precision,
        size_compressed,
        unit,
        ( double )100 - ( ( ( double )size_compressed * ( double )100 ) / ( double )size_original )
    );
}

/*!
 * 
 */
void egz_print_file_ptr( FILE * fp )
{
    char         c;
    char       * buffer;
    unsigned int length;
    unsigned int offset;
    unsigned int i;
    
    length = 0;
    offset = 0;
    
    fseek( fp, 0, SEEK_SET );
    
    if( NULL == ( buffer = ( char * )malloc( sizeof( char ) * 16 ) ) )
    {
        printf( "Error: not enough memory" );
        fclose( fp );
        exit( EXIT_FAILURE );
    }
    
    printf( "\n    -----------------------------------------------------------------------------------------------\n" );
    
    while( ( length = fread( buffer, sizeof( char ), 16, fp ) ) > 0 )
    {
        printf( "    | %010d | ", offset );
        
        offset += 16;
        
        for( i = 0; i < 16; i++ )
        {
            if( i % 4 == 0 && i != 0 )
            {
                printf( "  " );
            }
            
            if( i < length )
            {
                printf( "%02X", ( unsigned char )buffer[ i ] );
            }
            else
            {
                printf( "  " );
            }
            
            if( i < 15 )
            {
                printf( " " );
            }
        }
        
        printf( " | " );
            
        for( i = 0; i < 16; i++ )
        {
            c = 0;
            
            if( i % 4 == 0 && i != 0 )
            {
                printf( "  " );
            }
            
            if( i < length )
            {
                c = buffer[ i ];
                
                if( ( ( ( c & 0x80 ) == 0 ) && isprint( ( int )c ) ) )
                {
                    printf( "%c", c );
                }
                else
                {
                    printf( "." );
                }
            }
            else
            {
                printf( " " );
            }
        }
        
        printf( " |\n" );
    }
    
    printf( "    -----------------------------------------------------------------------------------------------\n\n" );
    
    free( buffer );
}
